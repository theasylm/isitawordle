{
  "version": 3,
  "sources": ["../../vue-final-modal/lib/utils/focusTrap.js", "../../vue-final-modal/lib/utils/dragResize.js", "../../vue-final-modal/lib/utils/bodyScrollLock.js", "../../vue-final-modal/lib/VueFinalModal.vue", "../../vue-final-modal/lib/VueFinalModal.vue?vue&type=template&id=2836fdb5&lang.js", "../../vue-final-modal/node_modules/style-inject/dist/style-inject.es.js", "../../vue-final-modal/lib/ModalsContainer.vue", "../../vue-final-modal/lib/ModalsContainer.vue?vue&type=template&id=74d49173&lang.js", "../../vue-final-modal/lib/PluginCore.js", "../../vue-final-modal/lib/Plugin.js", "dep:vue-final-modal"],
  "sourcesContent": ["// stolen from vue-js-modal\n\nconst FOCUSABLE_ELEMENTS_QUERY =\n  'button:not([disabled]), ' +\n  'select:not([disabled]), ' +\n  'a[href]:not([disabled]), ' +\n  'area[href]:not([disabled]), ' +\n  '[contentEditable=\"\"]:not([disabled]), ' +\n  '[contentEditable=\"true\"]:not([disabled]), ' +\n  '[contentEditable=\"TRUE\"]:not([disabled]), ' +\n  'textarea:not([disabled]), ' +\n  'iframe:not([disabled]), ' +\n  'input:not([disabled]), ' +\n  'summary:not([disabled]), ' +\n  '[tabindex]:not([tabindex=\"-1\"])'\n\nconst isTabPressed = event => {\n  return event.key === 'Tab' || event.keyCode === 9\n}\n\nconst querySelectorAll = (element, selector) => {\n  return [...(element.querySelectorAll(selector) || [])]\n}\n\nconst queryFocusableElements = element => {\n  return querySelectorAll(element, FOCUSABLE_ELEMENTS_QUERY)\n}\n\nconst isFocused = element => {\n  return element == document.activeElement\n}\n\nconst isNothingFocused = () => {\n  return !document.activeElement\n}\n\nclass FocusTrap {\n  constructor() {\n    this.root = null\n    this.elements = []\n\n    this.onKeyDown = this.onKeyDown.bind(this)\n    this.enable = this.enable.bind(this)\n    this.disable = this.disable.bind(this)\n    this.firstElement = this.firstElement.bind(this)\n    this.lastElement = this.lastElement.bind(this)\n  }\n\n  lastElement() {\n    return this.elements[this.elements.length - 1] || null\n  }\n\n  firstElement() {\n    return this.elements[0] || null\n  }\n\n  onKeyDown(event) {\n    if (!isTabPressed(event)) {\n      return\n    }\n\n    // SHIFT + TAB\n    if (event.shiftKey) {\n      if (isFocused(this.firstElement())) {\n        this.lastElement().focus()\n        event.preventDefault()\n      }\n      return\n    }\n\n    // TAB\n    if (isNothingFocused() || isFocused(this.lastElement())) {\n      this.firstElement().focus()\n      event.preventDefault()\n      return\n    }\n  }\n\n  enabled() {\n    return !!this.root\n  }\n\n  enable(root) {\n    if (!root) {\n      return\n    }\n\n    this.root = root\n    this.elements = queryFocusableElements(this.root)\n\n    this.root.addEventListener('keydown', this.onKeyDown)\n  }\n\n  disable() {\n    this.root.removeEventListener('keydown', this.onKeyDown)\n    this.root = null\n  }\n}\n\nexport default FocusTrap\n", "export const setStyle = (el, key, value) => {\n  const cacheStyle = el.style[key]\n  el.style[key] = value\n  return () => {\n    el.style[key] = cacheStyle\n  }\n}\n\nexport const getPosition = e => {\n  const { clientX: x, clientY: y } = e.targetTouches ? e.targetTouches[0] : e\n  return { x, y }\n}\n\nexport const capitalize = s => {\n  return s.charAt(0).toUpperCase() + s.slice(1)\n}\n\nexport const clamp = (min, num, max) => {\n  if (typeof min !== 'number') {\n    min = Math.min(num, max) || num\n  }\n  if (typeof max !== 'number') {\n    max = Math.max(num, min)\n  }\n  return Math.min(Math.max(num, min), max)\n}\n\nexport const trimPx = distance => {\n  return (distance && Number(distance.replace(/px$/, ''))) || 0\n}\n\nexport const validDragElement = (e, el, dragSelector) => {\n  if (dragSelector === '') return true\n  const list = [...el.querySelectorAll(dragSelector)]\n  return list.includes(e.target)\n}\n\nconst pointerType = {\n  down: {\n    pc: 'mousedown',\n    m: 'touchstart'\n  },\n  move: {\n    pc: 'mousemove',\n    m: 'touchmove'\n  },\n  up: {\n    pc: 'mouseup',\n    m: 'touchend'\n  }\n}\nexport const addListener = (type, el, callback) => {\n  el && el.addEventListener(pointerType[type].pc, callback)\n  el && el.addEventListener(pointerType[type].m, callback, { passive: false })\n}\nexport const removeListener = (type, el, callback) => {\n  el && el.removeEventListener(pointerType[type].pc, callback)\n  el && el.removeEventListener(pointerType[type].m, callback)\n}\n", "// stolen from body-scroll-lock\n\n// Older browsers don't support event options, feature detect it.\nlet hasPassiveEvents = false\nif (typeof window !== 'undefined') {\n  const passiveTestOptions = {\n    get passive() {\n      hasPassiveEvents = true\n      return undefined\n    }\n  }\n  window.addEventListener('testPassive', null, passiveTestOptions)\n  window.removeEventListener('testPassive', null, passiveTestOptions)\n}\n\nconst isIosDevice =\n  typeof window !== 'undefined' &&\n  window.navigator &&\n  window.navigator.platform &&\n  (/iP(ad|hone|od)/.test(window.navigator.platform) ||\n    (window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1))\n\nlet locks = []\nlet documentListenerAdded = false\nlet clientY = 0\nlet initialClientY = -1\nlet previousBodyOverflowSetting\nlet previousBodyPaddingRight\n\nconst hasScrollbar = el => {\n  if (!el || el.nodeType !== Node.ELEMENT_NODE) return false\n\n  const style = window.getComputedStyle(el)\n  return ['auto', 'scroll'].includes(style.overflowY) && el.scrollHeight > el.clientHeight\n}\n\nconst shouldScroll = (el, delta) => {\n  if (el.scrollTop === 0 && delta < 0) return false\n  if (el.scrollTop + el.clientHeight + delta >= el.scrollHeight && delta > 0) return false\n  return true\n}\n\nconst composedPath = el => {\n  const path = []\n  while (el) {\n    path.push(el)\n    if (el.classList.contains('vfm')) return path\n    el = el.parentElement\n  }\n  return path\n}\n\nconst hasAnyScrollableEl = (el, delta) => {\n  let hasAnyScrollableEl = false\n  const path = composedPath(el)\n  path.forEach(el => {\n    if (hasScrollbar(el) && shouldScroll(el, delta)) {\n      hasAnyScrollableEl = true\n    }\n  })\n  return hasAnyScrollableEl\n}\n\n// returns true if `el` should be allowed to receive touchmove events.\nconst allowTouchMove = el => locks.some(() => hasAnyScrollableEl(el, -clientY))\n\nconst preventDefault = rawEvent => {\n  const e = rawEvent || window.event\n\n  // For the case whereby consumers adds a touchmove event listener to document.\n  // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })\n  // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then\n  // the touchmove event on document will break.\n  if (allowTouchMove(e.target)) {\n    return true\n  }\n  // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).\n  if (e.touches.length > 1) return true\n\n  if (e.preventDefault) e.preventDefault()\n\n  return false\n}\n\nconst setOverflowHidden = options => {\n  // If previousBodyPaddingRight is already set, don't set it again.\n  if (previousBodyPaddingRight === undefined) {\n    const reserveScrollBarGap = !!options && options.reserveScrollBarGap === true\n    const scrollBarGap = window.innerWidth - document.documentElement.clientWidth\n\n    if (reserveScrollBarGap && scrollBarGap > 0) {\n      const computedBodyPaddingRight = parseInt(getComputedStyle(document.body).getPropertyValue('padding-right'), 10)\n      previousBodyPaddingRight = document.body.style.paddingRight\n      document.body.style.paddingRight = `${computedBodyPaddingRight + scrollBarGap}px`\n    }\n  }\n  // If previousBodyOverflowSetting is already set, don't set it again.\n  if (previousBodyOverflowSetting === undefined) {\n    previousBodyOverflowSetting = document.body.style.overflow\n    document.body.style.overflow = 'hidden'\n  }\n}\n\nconst restoreOverflowSetting = () => {\n  if (previousBodyPaddingRight !== undefined) {\n    document.body.style.paddingRight = previousBodyPaddingRight\n\n    // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it\n    // can be set again.\n    previousBodyPaddingRight = undefined\n  }\n\n  if (previousBodyOverflowSetting !== undefined) {\n    document.body.style.overflow = previousBodyOverflowSetting\n\n    // Restore previousBodyOverflowSetting to undefined\n    // so setOverflowHidden knows it can be set again.\n    previousBodyOverflowSetting = undefined\n  }\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions\nconst isTargetElementTotallyScrolled = targetElement =>\n  targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false\n\nconst handleScroll = (event, targetElement) => {\n  clientY = event.targetTouches[0].clientY - initialClientY\n\n  if (allowTouchMove(event.target)) {\n    return false\n  }\n\n  if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {\n    // element is at the top of its scroll.\n    return preventDefault(event)\n  }\n\n  if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {\n    // element is at the bottom of its scroll.\n    return preventDefault(event)\n  }\n\n  event.stopPropagation()\n  return true\n}\n\nexport const disableBodyScroll = (targetElement, options) => {\n  // targetElement must be provided\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.'\n    )\n    return\n  }\n\n  // disableBodyScroll must not have been called on this targetElement before\n  if (locks.some(lock => lock.targetElement === targetElement)) {\n    return\n  }\n\n  const lock = {\n    targetElement,\n    options: options || {}\n  }\n\n  locks = [...locks, lock]\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = event => {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        initialClientY = event.targetTouches[0].clientY\n      }\n    }\n    targetElement.ontouchmove = event => {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        handleScroll(event, targetElement)\n      }\n    }\n\n    if (!documentListenerAdded) {\n      document.addEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined)\n      documentListenerAdded = true\n    }\n  } else {\n    setOverflowHidden(options)\n  }\n}\n\nexport const enableBodyScroll = targetElement => {\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.'\n    )\n    return\n  }\n\n  locks = locks.filter(lock => lock.targetElement !== targetElement)\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = null\n    targetElement.ontouchmove = null\n\n    if (documentListenerAdded && locks.length === 0) {\n      document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined)\n      documentListenerAdded = false\n    }\n  } else if (!locks.length) {\n    restoreOverflowSetting()\n  }\n}\n", "<template>\n  <div\n    v-if=\"ssr || visible\"\n    v-show=\"!ssr || visible\"\n    ref=\"root\"\n    :style=\"bindStyle\"\n    class=\"vfm vfm--inset\"\n    :class=\"[attach === false ? 'vfm--fixed' : 'vfm--absolute', { 'vfm--prevent-none': preventClick }]\"\n    @keydown.esc=\"onEsc\"\n  >\n    <transition\n      v-bind=\"computedOverlayTransition\"\n      @before-enter=\"beforeOverlayEnter\"\n      @after-enter=\"afterOverlayEnter\"\n      @before-leave=\"beforeOverlayLeave\"\n      @after-leave=\"afterOverlayLeave\"\n    >\n      <div\n        v-if=\"!hideOverlay && visibility.overlay\"\n        class=\"vfm__overlay vfm--overlay vfm--absolute vfm--inset\"\n        :class=\"overlayClass\"\n        :style=\"overlayStyle\"\n      ></div>\n    </transition>\n    <transition\n      v-bind=\"computedTransition\"\n      @before-enter=\"beforeModalEnter\"\n      @after-enter=\"afterModalEnter\"\n      @before-leave=\"beforeModalLeave\"\n      @after-leave=\"afterModalLeave\"\n    >\n      <div\n        v-show=\"visibility.modal\"\n        ref=\"vfmContainer\"\n        class=\"vfm__container vfm--absolute vfm--inset vfm--outline-none\"\n        :class=\"classes\"\n        :style=\"styles\"\n        :aria-expanded=\"visibility.modal.toString()\"\n        role=\"dialog\"\n        aria-modal=\"true\"\n        tabindex=\"-1\"\n        @mouseup.self=\"onMouseupContainer\"\n        @mousedown.self=\"onMousedown\"\n      >\n        <div\n          ref=\"vfmContent\"\n          class=\"vfm__content\"\n          :class=\"[contentClass, { 'vfm--prevent-auto': preventClick }]\"\n          :style=\"bindContentStyle\"\n          @mousedown=\"onMousedown(null)\"\n        >\n          <slot :params=\"params\" :close=\"() => $emit('update:modelValue', false)\" />\n          <div\n            v-if=\"visibility.resize && visibility.modal\"\n            ref=\"vfmResize\"\n            class=\"vfm__resize vfm--absolute vfm--inset vfm--prevent-none vfm--select-none vfm--touch-none\"\n          >\n            <div\n              v-for=\"direction in resizeDirections\"\n              :key=\"direction\"\n              :direction=\"direction\"\n              :class=\"`vfm--resize-${direction}`\"\n              class=\"vfm--absolute vfm--prevent-auto\"\n            ></div>\n          </div>\n        </div>\n      </div>\n    </transition>\n  </div>\n</template>\n\n<script>\n/* eslint-disable vue/no-mutating-props */\nimport { ref, reactive, onMounted, onBeforeUnmount, computed, nextTick, watch } from 'vue'\nimport FocusTrap from './utils/focusTrap.js'\nimport {\n  setStyle,\n  getPosition,\n  capitalize,\n  clamp,\n  trimPx,\n  validDragElement,\n  addListener,\n  removeListener\n} from './utils/dragResize.js'\nimport { disableBodyScroll, enableBodyScroll } from './utils/bodyScrollLock'\n\nconst noop = () => {}\n\nconst TransitionState = {\n  Enter: 'enter',\n  Entering: 'entering',\n  Leave: 'leave',\n  Leaving: 'leavng'\n}\n\nconst resizeCursor = {\n  t: 'ns-resize',\n  tr: 'nesw-resize',\n  r: 'ew-resize',\n  br: 'nwse-resize',\n  b: 'ns-resize',\n  bl: 'nesw-resize',\n  l: 'ew-resize',\n  tl: 'nwse-resize'\n}\n\nexport default {\n  props: {\n    name: { type: String, default: null },\n    modelValue: { type: Boolean, default: false },\n    ssr: { type: Boolean, default: true },\n    classes: { type: [String, Object, Array], default: '' },\n    overlayClass: { type: [String, Object, Array], default: '' },\n    contentClass: { type: [String, Object, Array], default: '' },\n    styles: { type: [Object, Array], default: () => ({}) },\n    overlayStyle: { type: [Object, Array], default: () => ({}) },\n    contentStyle: { type: [Object, Array], default: () => ({}) },\n    lockScroll: { type: Boolean, default: true },\n    hideOverlay: { type: Boolean, default: false },\n    clickToClose: { type: Boolean, default: true },\n    escToClose: { type: Boolean, default: false },\n    preventClick: { type: Boolean, default: false },\n    attach: {\n      type: null,\n      default: false,\n      validator(val) {\n        const type = typeof val\n\n        if (type === 'boolean' || type === 'string') return true\n\n        return val.nodeType === Node.ELEMENT_NODE\n      }\n    },\n    transition: { type: [String, Object], default: 'vfm' },\n    overlayTransition: { type: [String, Object], default: 'vfm' },\n    keepOverlay: { type: Boolean, default: false },\n    zIndexAuto: { type: Boolean, default: true },\n    zIndexBase: { type: [String, Number], default: 1000 },\n    zIndex: { type: [Boolean, String, Number], default: false },\n    focusRetain: { type: Boolean, default: true },\n    focusTrap: { type: Boolean, default: false },\n    fitParent: { type: Boolean, default: true },\n    drag: { type: Boolean, default: false },\n    dragSelector: { type: String, default: '' },\n    keepChangedStyle: { type: Boolean, default: false },\n    resize: {\n      type: Boolean,\n      default: false\n    },\n    resizeDirections: {\n      type: Array,\n      default: () => ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'],\n      validator: val =>\n        ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'].filter(value => val.indexOf(value) !== -1).length === val.length\n    },\n    minWidth: { type: Number, default: 0 },\n    minHeight: { type: Number, default: 0 },\n    maxWidth: { type: Number, default: Infinity },\n    maxHeight: { type: Number, default: Infinity }\n  },\n  emits: [\n    'update:modelValue',\n    'click-outside',\n    'before-open',\n    'opened',\n    'before-close',\n    'closed',\n    '_before-open',\n    '_opened',\n    '_closed',\n    'drag:start',\n    'drag:move',\n    'drag:end',\n    'resize:start',\n    'resize:move',\n    'resize:end'\n  ],\n  setup(props, { emit }) {\n    const uid = Symbol('vfm')\n    const root = ref(null)\n    const vfmContainer = ref(null)\n    const vfmContent = ref(null)\n    const vfmResize = ref(null)\n    const vfmOverlayTransition = ref(null)\n    const vfmTransition = ref(null)\n\n    const modalStackIndex = ref(null)\n    const $focusTrap = new FocusTrap()\n\n    const visible = ref(false)\n    const visibility = reactive({\n      modal: false,\n      overlay: false,\n      resize: false\n    })\n    const overlayTransitionState = ref(null)\n    const modalTransitionState = ref(null)\n    const _stopEvent = ref(false)\n    const params = ref({})\n    const dragResizeStyle = ref({})\n    const _state = ref(null)\n    const lastMousedownEl = ref(null)\n\n    let resolveToggle = noop\n    let rejectToggle = noop\n\n    const computedOverlayTransition = computed(() => {\n      if (typeof props.overlayTransition === 'string') return { name: props.overlayTransition }\n      return { ...props.overlayTransition }\n    })\n\n    const computedTransition = computed(() => {\n      if (typeof props.transition === 'string') return { name: props.transition }\n      return { ...props.transition }\n    })\n\n    const isComponentReadyToBeDestroyed = computed(() => {\n      return (\n        (props.hideOverlay || overlayTransitionState.value === TransitionState.Leave) &&\n        modalTransitionState.value === TransitionState.Leave\n      )\n    })\n\n    const calculateZIndex = computed(() => {\n      if (props.zIndex === false) {\n        if (props.zIndexAuto) {\n          return +props.zIndexBase + 2 * (modalStackIndex.value || 0)\n        } else {\n          return false\n        }\n      } else {\n        return props.zIndex\n      }\n    })\n\n    const bindStyle = computed(() => {\n      return {\n        ...(calculateZIndex.value !== false && {\n          zIndex: calculateZIndex.value\n        })\n      }\n    })\n\n    const bindContentStyle = computed(() => {\n      let style = [dragResizeStyle.value]\n      Array.isArray(props.contentStyle) ? style.push(...props.contentStyle) : style.push(props.contentStyle)\n      return style\n    })\n\n    watch(\n      () => props.modelValue,\n      value => {\n        if (_stopEvent.value) {\n          _stopEvent.value = false\n          return\n        }\n        mounted()\n        if (!value) {\n          if (emitEvent('before-close', true)) {\n            rejectToggle('hide')\n            return\n          }\n          close()\n        }\n      }\n    )\n    watch(() => props.lockScroll, handleLockScroll)\n    watch(\n      () => props.hideOverlay,\n      value => {\n        if (props.modelValue && !value) {\n          visibility.overlay = true\n        }\n      }\n    )\n    watch(() => props.attach, mounted)\n    watch(\n      isComponentReadyToBeDestroyed,\n      val => {\n        if (val) {\n          visible.value = false\n          vfmContainer.value.style.display = 'none'\n        }\n      },\n      {\n        flush: 'post'\n      }\n    )\n    watch(\n      () => props.drag,\n      val => {\n        if (visible.value) {\n          val ? addDragDown() : removeDragDown()\n        }\n      }\n    )\n    watch(\n      () => props.resize,\n      val => {\n        if (visible.value) {\n          val ? addResizeDown() : removeResizeDown()\n        }\n      }\n    )\n    watch(\n      () => props.keepChangedStyle,\n      val => {\n        if (!val) {\n          dragResizeStyle.value = {}\n        }\n      }\n    )\n\n    props.api.modals.push(getModalInfo())\n\n    onMounted(() => {\n      mounted()\n    })\n    onBeforeUnmount(() => {\n      close()\n      props.lockScroll && vfmContainer.value && enableBodyScroll(vfmContainer.value)\n      root?.value?.remove()\n\n      let index = props.api.modals.findIndex(vm => vm.uid === uid)\n\n      props.api.modals.splice(index, 1)\n    })\n    function getModalInfo() {\n      return {\n        uid,\n        props,\n        emit,\n        vfmContainer,\n        vfmContent,\n        vfmResize,\n        vfmOverlayTransition,\n        vfmTransition,\n        getAttachElement,\n        modalStackIndex,\n        visibility,\n        handleLockScroll,\n        $focusTrap,\n        toggle,\n        params\n      }\n    }\n    function mounted() {\n      if (props.modelValue) {\n        emit('_before-open', createModalEvent({ type: '_before-open' }))\n        if (emitEvent('before-open', false)) {\n          rejectToggle('show')\n          return\n        }\n\n        let target = getAttachElement()\n        if (target || props.attach === false) {\n          if (props.attach !== false) {\n            if (root.value) {\n              target.appendChild(root.value)\n            } else {\n              visible.value = true\n              nextTick(() => {\n                mounted()\n              })\n              return\n            }\n          }\n\n          let index = props.api.openedModals.findIndex(vm => vm.uid === uid)\n\n          if (index !== -1) {\n            // if this is already exist in modalStack, delete it\n            props.api.openedModals.splice(index, 1)\n          }\n          props.api.openedModals.push(getModalInfo())\n\n          modalStackIndex.value = props.api.openedModals.length - 1\n\n          handleLockScroll()\n\n          props.api.openedModals\n            .filter(vm => vm.uid !== uid)\n            .forEach((vm, index) => {\n              if (vm.getAttachElement() === target) {\n                // if vm and this have the same attach element\n                vm.modalStackIndex.value = index\n                !vm.props.keepOverlay && (vm.visibility.overlay = false)\n              }\n            })\n\n          visible.value = true\n          startTransitionEnter()\n        } else if (target !== false) {\n          console.warn('Unable to locate target '.concat(props.attach))\n        }\n      }\n    }\n    function close() {\n      let index = props.api.openedModals.findIndex(vm => vm.uid === uid)\n      if (index !== -1) {\n        // remove this in modalStack\n        props.api.openedModals.splice(index, 1)\n      }\n      if (props.api.openedModals.length > 0) {\n        // If there are still nested modals opened\n        const $_vm = props.api.openedModals[props.api.openedModals.length - 1]\n        $_vm.props.focusTrap && $_vm.$focusTrap.firstElement().focus()\n        if ($_vm.props.focusRetain || $_vm.props.focusTrap) {\n          $_vm.vfmContainer.value.focus()\n        }\n        !$_vm.props.hideOverlay && ($_vm.visibility.overlay = true)\n      }\n      props.drag && removeDragDown()\n      props.resize && removeResizeDown()\n      _state.value = null\n\n      startTransitionLeave()\n    }\n    function handleLockScroll() {\n      if (props.modelValue) {\n        nextTick(() => {\n          if (props.lockScroll) {\n            disableBodyScroll(vfmContainer.value, {\n              reserveScrollBarGap: true\n            })\n          } else {\n            enableBodyScroll(vfmContainer.value)\n          }\n        })\n      }\n    }\n    function getAttachElement() {\n      let target\n      if (props.attach === false) {\n        target = false\n      } else if (typeof props.attach === 'string') {\n        // CSS selector\n        if (window) {\n          target = window.document.querySelector(props.attach)\n        } else {\n          target = false\n        }\n      } else {\n        // DOM Element\n        target = props.attach\n      }\n      return target\n    }\n    function startTransitionEnter() {\n      visibility.overlay = true\n      visibility.modal = true\n    }\n    function startTransitionLeave() {\n      visibility.overlay = false\n      visibility.modal = false\n    }\n\n    function beforeOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Entering\n    }\n    function afterOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Enter\n    }\n    function beforeOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leaving\n    }\n    function afterOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leave\n    }\n    function beforeModalEnter() {\n      modalTransitionState.value = TransitionState.Entering\n    }\n    function afterModalEnter() {\n      modalTransitionState.value = TransitionState.Enter\n      if (props.focusRetain || props.focusTrap) {\n        vfmContainer.value.focus()\n      }\n      props.focusTrap && $focusTrap.enable(vfmContainer.value)\n      props.drag && addDragDown()\n      props.resize && addResizeDown()\n\n      emit('_opened')\n      emit('opened', createModalEvent({ type: 'opened' }))\n      resolveToggle('show')\n    }\n    function beforeModalLeave() {\n      modalTransitionState.value = TransitionState.Leaving\n\n      if ($focusTrap.enabled()) {\n        $focusTrap.disable()\n      }\n    }\n    function afterModalLeave() {\n      modalTransitionState.value = TransitionState.Leave\n      modalStackIndex.value = null\n      props.lockScroll && enableBodyScroll(vfmContainer.value)\n      if (!props.keepChangedStyle) {\n        dragResizeStyle.value = {}\n      }\n\n      let stopEvent = false\n      const event = createModalEvent({\n        type: 'closed',\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit('_closed')\n      emit('closed', event)\n      resolveToggle('hide')\n      if (stopEvent) return\n      params.value = {}\n    }\n    function onMousedown(e) {\n      lastMousedownEl.value = e?.target\n    }\n    function onMouseupContainer() {\n      // skip when the lastMousedownEl didn't equal vfmContainer\n      if (lastMousedownEl.value !== vfmContainer.value) return\n      // skip when state equal 'resize:move'\n      if (_state.value === 'resize:move') return\n      emit('click-outside', createModalEvent({ type: 'click-outside' }))\n      props.clickToClose && emit('update:modelValue', false)\n    }\n    function onEsc() {\n      if (visible.value && props.escToClose) {\n        emit('update:modelValue', false)\n      }\n    }\n    function createModalEvent(eventProps = {}) {\n      return {\n        ref: getModalInfo(),\n        ...eventProps\n      }\n    }\n    function emitEvent(eventType, value) {\n      let stopEvent = false\n      const event = createModalEvent({\n        type: eventType,\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit(eventType, event)\n      if (stopEvent) {\n        _stopEvent.value = true\n        nextTick(() => {\n          emit('update:modelValue', value)\n        })\n        return true\n      }\n      return false\n    }\n    function emitState(e, state, action) {\n      _state.value = `${state}:${action}`\n      emit(_state.value, e)\n    }\n    function toggle(show, _params) {\n      return new Promise((resolve, reject) => {\n        resolveToggle = res => {\n          resolve(res)\n          resolveToggle = noop\n        }\n        rejectToggle = err => {\n          reject(err)\n          rejectToggle = noop\n        }\n        const value = typeof show === 'boolean' ? show : !props.modelValue\n        if (value && arguments.length === 2) {\n          params.value = _params\n        }\n        emit('update:modelValue', value)\n      })\n    }\n    function pointerDown(e) {\n      e.stopPropagation()\n      const STATE_RESIZE = 'resize'\n      const STATE_DRAG = 'drag'\n      const direction = e.target.getAttribute('direction')\n      let state\n      if (direction) {\n        state = STATE_RESIZE\n      } else if (validDragElement(e, vfmContent.value, props.dragSelector)) {\n        state = STATE_DRAG\n      } else {\n        return\n      }\n      emitState(e, state, 'start')\n      const down = getPosition(e)\n      const rectContainer = vfmContainer.value.getBoundingClientRect()\n      const rectContent = vfmContent.value.getBoundingClientRect()\n      const isAbsolute = window.getComputedStyle(vfmContent.value).position === 'absolute'\n      const position = {\n        top: trimPx(dragResizeStyle.value.top),\n        left: trimPx(dragResizeStyle.value.left)\n      }\n      const limit = (() => {\n        if (props.fitParent) {\n          const limit = {\n            absolute() {\n              return {\n                minTop: 0,\n                minLeft: 0,\n                maxTop: rectContainer.height - rectContent.height,\n                maxLeft: rectContainer.width - rectContent.width\n              }\n            },\n            relative() {\n              return {\n                minTop: position.top + rectContainer.top - rectContent.top,\n                minLeft: position.left + rectContainer.left - rectContent.left,\n                maxTop: position.top + rectContainer.bottom - rectContent.bottom,\n                maxLeft: position.left + rectContainer.right - rectContent.right\n              }\n            }\n          }\n          return isAbsolute ? limit.absolute() : limit.relative()\n        } else {\n          return {}\n        }\n      })()\n      const resetBodyCursor = state === STATE_RESIZE && setStyle(document.body, 'cursor', resizeCursor[direction])\n\n      const moving = e => {\n        // onPointerMove\n        e.stopPropagation()\n        emitState(e, state, 'move')\n        const move = getPosition(e)\n        let offset = {\n          x: move.x - down.x,\n          y: move.y - down.y\n        }\n        if (state === STATE_RESIZE) {\n          offset = getResizeOffset(direction, offset, rectContainer, rectContent, isAbsolute)\n        }\n\n        let top\n        let left\n        if (isAbsolute) {\n          top = rectContent.top - rectContainer.top + offset.y\n          left = rectContent.left - rectContainer.left + offset.x\n        } else {\n          top = position.top + offset.y\n          left = position.left + offset.x\n        }\n        if (state === STATE_DRAG && props.fitParent) {\n          top = clamp(limit.minTop, top, limit.maxTop)\n          left = clamp(limit.minLeft, left, limit.maxLeft)\n        }\n        const style = {\n          position: 'relative',\n          top: top + 'px',\n          left: left + 'px',\n          margin: 'unset',\n          touchAction: 'none',\n          ...(isAbsolute && {\n            position: 'absolute',\n            transform: 'unset',\n            width: rectContent.width + 'px',\n            height: rectContent.height + 'px'\n          }),\n          ...(offset.width && { width: offset.width + 'px' }),\n          ...(offset.height && { height: offset.height + 'px' })\n        }\n\n        dragResizeStyle.value = {\n          ...dragResizeStyle.value,\n          ...style\n        }\n      }\n      const end = e => {\n        // onPointerUp\n        e.stopPropagation()\n        if (state === STATE_RESIZE) {\n          resetBodyCursor && resetBodyCursor()\n        }\n        // Excute onMouseupContainer before trigger emitState\n        setTimeout(() => {\n          emitState(e, state, 'end')\n        })\n        removeListener('move', document, moving)\n        removeListener('up', document, end)\n      }\n      addListener('move', document, moving)\n      addListener('up', document, end)\n    }\n    function addDragDown() {\n      addListener('down', vfmContent.value, pointerDown)\n      dragResizeStyle.value.touchAction = 'none'\n    }\n    function removeDragDown() {\n      removeListener('down', vfmContent.value, pointerDown)\n    }\n    function addResizeDown() {\n      visibility.resize = true\n      nextTick(() => {\n        addListener('down', vfmResize.value, pointerDown)\n      })\n    }\n    function removeResizeDown() {\n      removeListener('down', vfmResize.value, pointerDown)\n      visibility.resize = false\n    }\n    function getResizeOffset(direction, offset, rectContainer, rectContent, isAbsolute) {\n      const setOffset = dir => {\n        let offsetAxis = offset[dir.axis]\n        offsetAxis = props.fitParent ? clamp(dir.min, offsetAxis, dir.max) : offsetAxis\n        let edge = clamp(dir.minEdge, dir.getEdge(offsetAxis), dir.maxEdge)\n        offsetAxis = dir.getOffsetAxis(edge, isAbsolute)\n        return {\n          [dir.edgeName]: edge,\n          [dir.axis]: offsetAxis\n        }\n      }\n\n      const getDirectionInfo = (position, edgeName, axis, isPositive) => {\n        const rectContentEdge = rectContent[edgeName]\n        const positionOffset = rectContainer[position] - rectContent[position]\n        const EdgeName = capitalize(edgeName)\n        return {\n          axis,\n          edgeName,\n          min: isPositive ? positionOffset : -rectContentEdge,\n          max: isPositive ? rectContentEdge : positionOffset,\n          minEdge: props[`min${EdgeName}`],\n          maxEdge: props[`max${EdgeName}`],\n          getEdge: offsetAxis => rectContent[edgeName] - offsetAxis * (isPositive ? 1 : -1),\n          getOffsetAxis: (edge, isAbsolute) => {\n            const offsetAxis = rectContent[edgeName] - edge\n            if (isAbsolute) {\n              return isPositive ? offsetAxis : 0\n            } else {\n              return ((isPositive ? 1 : -1) * offsetAxis) / 2\n            }\n          }\n        }\n      }\n\n      const directions = {\n        t: ['top', 'height', 'y', true],\n        b: ['bottom', 'height', 'y', false],\n        l: ['left', 'width', 'x', true],\n        r: ['right', 'width', 'x', false]\n      }\n\n      let _offset = { x: 0, y: 0 }\n      direction.split('').forEach(dir => {\n        const directionInfo = getDirectionInfo(...directions[dir])\n        _offset = {\n          ..._offset,\n          ...setOffset(directionInfo)\n        }\n      })\n      return _offset\n    }\n    return {\n      root,\n      vfmContainer,\n      vfmContent,\n      vfmResize,\n      vfmOverlayTransition,\n      vfmTransition,\n      computedOverlayTransition,\n      computedTransition,\n      visible,\n      visibility,\n      params,\n      calculateZIndex,\n      bindStyle,\n      bindContentStyle,\n      beforeOverlayEnter,\n      afterOverlayEnter,\n      beforeOverlayLeave,\n      afterOverlayLeave,\n      beforeModalEnter,\n      afterModalEnter,\n      beforeModalLeave,\n      afterModalLeave,\n      onMousedown,\n      onMouseupContainer,\n      onEsc\n    }\n  }\n}\n</script>\n\n<style lang=\"css\" scoped>\n.vfm--fixed {\n  position: fixed;\n}\n.vfm--absolute {\n  position: absolute;\n}\n.vfm--inset {\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.vfm--overlay {\n  background-color: rgba(0, 0, 0, 0.5);\n}\n.vfm--prevent-none {\n  pointer-events: none;\n}\n.vfm--prevent-auto {\n  pointer-events: auto;\n}\n.vfm--outline-none:focus {\n  outline: none;\n}\n.vfm-enter-active,\n.vfm-leave-active {\n  transition: opacity 0.2s;\n}\n.vfm-enter-from,\n.vfm-leave-to {\n  opacity: 0;\n}\n\n.vfm--touch-none {\n  touch-action: none;\n}\n.vfm--select-none {\n  user-select: none;\n}\n\n.vfm--resize-tr,\n.vfm--resize-br,\n.vfm--resize-bl,\n.vfm--resize-tl {\n  width: 12px;\n  height: 12px;\n  z-index: 10;\n}\n\n.vfm--resize-t {\n  top: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-tr {\n  top: -6px;\n  right: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-r {\n  top: 0;\n  right: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-br {\n  bottom: -6px;\n  right: -6px;\n  cursor: nwse-resize;\n}\n.vfm--resize-b {\n  bottom: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-bl {\n  bottom: -6px;\n  left: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-l {\n  top: 0;\n  left: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-tl {\n  top: -6px;\n  left: -6px;\n  cursor: nwse-resize;\n}\n</style>\n", "<template>\n  <div\n    v-if=\"ssr || visible\"\n    v-show=\"!ssr || visible\"\n    ref=\"root\"\n    :style=\"bindStyle\"\n    class=\"vfm vfm--inset\"\n    :class=\"[attach === false ? 'vfm--fixed' : 'vfm--absolute', { 'vfm--prevent-none': preventClick }]\"\n    @keydown.esc=\"onEsc\"\n  >\n    <transition\n      v-bind=\"computedOverlayTransition\"\n      @before-enter=\"beforeOverlayEnter\"\n      @after-enter=\"afterOverlayEnter\"\n      @before-leave=\"beforeOverlayLeave\"\n      @after-leave=\"afterOverlayLeave\"\n    >\n      <div\n        v-if=\"!hideOverlay && visibility.overlay\"\n        class=\"vfm__overlay vfm--overlay vfm--absolute vfm--inset\"\n        :class=\"overlayClass\"\n        :style=\"overlayStyle\"\n      ></div>\n    </transition>\n    <transition\n      v-bind=\"computedTransition\"\n      @before-enter=\"beforeModalEnter\"\n      @after-enter=\"afterModalEnter\"\n      @before-leave=\"beforeModalLeave\"\n      @after-leave=\"afterModalLeave\"\n    >\n      <div\n        v-show=\"visibility.modal\"\n        ref=\"vfmContainer\"\n        class=\"vfm__container vfm--absolute vfm--inset vfm--outline-none\"\n        :class=\"classes\"\n        :style=\"styles\"\n        :aria-expanded=\"visibility.modal.toString()\"\n        role=\"dialog\"\n        aria-modal=\"true\"\n        tabindex=\"-1\"\n        @mouseup.self=\"onMouseupContainer\"\n        @mousedown.self=\"onMousedown\"\n      >\n        <div\n          ref=\"vfmContent\"\n          class=\"vfm__content\"\n          :class=\"[contentClass, { 'vfm--prevent-auto': preventClick }]\"\n          :style=\"bindContentStyle\"\n          @mousedown=\"onMousedown(null)\"\n        >\n          <slot :params=\"params\" :close=\"() => $emit('update:modelValue', false)\" />\n          <div\n            v-if=\"visibility.resize && visibility.modal\"\n            ref=\"vfmResize\"\n            class=\"vfm__resize vfm--absolute vfm--inset vfm--prevent-none vfm--select-none vfm--touch-none\"\n          >\n            <div\n              v-for=\"direction in resizeDirections\"\n              :key=\"direction\"\n              :direction=\"direction\"\n              :class=\"`vfm--resize-${direction}`\"\n              class=\"vfm--absolute vfm--prevent-auto\"\n            ></div>\n          </div>\n        </div>\n      </div>\n    </transition>\n  </div>\n</template>\n\n<script>\n/* eslint-disable vue/no-mutating-props */\nimport { ref, reactive, onMounted, onBeforeUnmount, computed, nextTick, watch } from 'vue'\nimport FocusTrap from './utils/focusTrap.js'\nimport {\n  setStyle,\n  getPosition,\n  capitalize,\n  clamp,\n  trimPx,\n  validDragElement,\n  addListener,\n  removeListener\n} from './utils/dragResize.js'\nimport { disableBodyScroll, enableBodyScroll } from './utils/bodyScrollLock'\n\nconst noop = () => {}\n\nconst TransitionState = {\n  Enter: 'enter',\n  Entering: 'entering',\n  Leave: 'leave',\n  Leaving: 'leavng'\n}\n\nconst resizeCursor = {\n  t: 'ns-resize',\n  tr: 'nesw-resize',\n  r: 'ew-resize',\n  br: 'nwse-resize',\n  b: 'ns-resize',\n  bl: 'nesw-resize',\n  l: 'ew-resize',\n  tl: 'nwse-resize'\n}\n\nexport default {\n  props: {\n    name: { type: String, default: null },\n    modelValue: { type: Boolean, default: false },\n    ssr: { type: Boolean, default: true },\n    classes: { type: [String, Object, Array], default: '' },\n    overlayClass: { type: [String, Object, Array], default: '' },\n    contentClass: { type: [String, Object, Array], default: '' },\n    styles: { type: [Object, Array], default: () => ({}) },\n    overlayStyle: { type: [Object, Array], default: () => ({}) },\n    contentStyle: { type: [Object, Array], default: () => ({}) },\n    lockScroll: { type: Boolean, default: true },\n    hideOverlay: { type: Boolean, default: false },\n    clickToClose: { type: Boolean, default: true },\n    escToClose: { type: Boolean, default: false },\n    preventClick: { type: Boolean, default: false },\n    attach: {\n      type: null,\n      default: false,\n      validator(val) {\n        const type = typeof val\n\n        if (type === 'boolean' || type === 'string') return true\n\n        return val.nodeType === Node.ELEMENT_NODE\n      }\n    },\n    transition: { type: [String, Object], default: 'vfm' },\n    overlayTransition: { type: [String, Object], default: 'vfm' },\n    keepOverlay: { type: Boolean, default: false },\n    zIndexAuto: { type: Boolean, default: true },\n    zIndexBase: { type: [String, Number], default: 1000 },\n    zIndex: { type: [Boolean, String, Number], default: false },\n    focusRetain: { type: Boolean, default: true },\n    focusTrap: { type: Boolean, default: false },\n    fitParent: { type: Boolean, default: true },\n    drag: { type: Boolean, default: false },\n    dragSelector: { type: String, default: '' },\n    keepChangedStyle: { type: Boolean, default: false },\n    resize: {\n      type: Boolean,\n      default: false\n    },\n    resizeDirections: {\n      type: Array,\n      default: () => ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'],\n      validator: val =>\n        ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'].filter(value => val.indexOf(value) !== -1).length === val.length\n    },\n    minWidth: { type: Number, default: 0 },\n    minHeight: { type: Number, default: 0 },\n    maxWidth: { type: Number, default: Infinity },\n    maxHeight: { type: Number, default: Infinity }\n  },\n  emits: [\n    'update:modelValue',\n    'click-outside',\n    'before-open',\n    'opened',\n    'before-close',\n    'closed',\n    '_before-open',\n    '_opened',\n    '_closed',\n    'drag:start',\n    'drag:move',\n    'drag:end',\n    'resize:start',\n    'resize:move',\n    'resize:end'\n  ],\n  setup(props, { emit }) {\n    const uid = Symbol('vfm')\n    const root = ref(null)\n    const vfmContainer = ref(null)\n    const vfmContent = ref(null)\n    const vfmResize = ref(null)\n    const vfmOverlayTransition = ref(null)\n    const vfmTransition = ref(null)\n\n    const modalStackIndex = ref(null)\n    const $focusTrap = new FocusTrap()\n\n    const visible = ref(false)\n    const visibility = reactive({\n      modal: false,\n      overlay: false,\n      resize: false\n    })\n    const overlayTransitionState = ref(null)\n    const modalTransitionState = ref(null)\n    const _stopEvent = ref(false)\n    const params = ref({})\n    const dragResizeStyle = ref({})\n    const _state = ref(null)\n    const lastMousedownEl = ref(null)\n\n    let resolveToggle = noop\n    let rejectToggle = noop\n\n    const computedOverlayTransition = computed(() => {\n      if (typeof props.overlayTransition === 'string') return { name: props.overlayTransition }\n      return { ...props.overlayTransition }\n    })\n\n    const computedTransition = computed(() => {\n      if (typeof props.transition === 'string') return { name: props.transition }\n      return { ...props.transition }\n    })\n\n    const isComponentReadyToBeDestroyed = computed(() => {\n      return (\n        (props.hideOverlay || overlayTransitionState.value === TransitionState.Leave) &&\n        modalTransitionState.value === TransitionState.Leave\n      )\n    })\n\n    const calculateZIndex = computed(() => {\n      if (props.zIndex === false) {\n        if (props.zIndexAuto) {\n          return +props.zIndexBase + 2 * (modalStackIndex.value || 0)\n        } else {\n          return false\n        }\n      } else {\n        return props.zIndex\n      }\n    })\n\n    const bindStyle = computed(() => {\n      return {\n        ...(calculateZIndex.value !== false && {\n          zIndex: calculateZIndex.value\n        })\n      }\n    })\n\n    const bindContentStyle = computed(() => {\n      let style = [dragResizeStyle.value]\n      Array.isArray(props.contentStyle) ? style.push(...props.contentStyle) : style.push(props.contentStyle)\n      return style\n    })\n\n    watch(\n      () => props.modelValue,\n      value => {\n        if (_stopEvent.value) {\n          _stopEvent.value = false\n          return\n        }\n        mounted()\n        if (!value) {\n          if (emitEvent('before-close', true)) {\n            rejectToggle('hide')\n            return\n          }\n          close()\n        }\n      }\n    )\n    watch(() => props.lockScroll, handleLockScroll)\n    watch(\n      () => props.hideOverlay,\n      value => {\n        if (props.modelValue && !value) {\n          visibility.overlay = true\n        }\n      }\n    )\n    watch(() => props.attach, mounted)\n    watch(\n      isComponentReadyToBeDestroyed,\n      val => {\n        if (val) {\n          visible.value = false\n          vfmContainer.value.style.display = 'none'\n        }\n      },\n      {\n        flush: 'post'\n      }\n    )\n    watch(\n      () => props.drag,\n      val => {\n        if (visible.value) {\n          val ? addDragDown() : removeDragDown()\n        }\n      }\n    )\n    watch(\n      () => props.resize,\n      val => {\n        if (visible.value) {\n          val ? addResizeDown() : removeResizeDown()\n        }\n      }\n    )\n    watch(\n      () => props.keepChangedStyle,\n      val => {\n        if (!val) {\n          dragResizeStyle.value = {}\n        }\n      }\n    )\n\n    props.api.modals.push(getModalInfo())\n\n    onMounted(() => {\n      mounted()\n    })\n    onBeforeUnmount(() => {\n      close()\n      props.lockScroll && vfmContainer.value && enableBodyScroll(vfmContainer.value)\n      root?.value?.remove()\n\n      let index = props.api.modals.findIndex(vm => vm.uid === uid)\n\n      props.api.modals.splice(index, 1)\n    })\n    function getModalInfo() {\n      return {\n        uid,\n        props,\n        emit,\n        vfmContainer,\n        vfmContent,\n        vfmResize,\n        vfmOverlayTransition,\n        vfmTransition,\n        getAttachElement,\n        modalStackIndex,\n        visibility,\n        handleLockScroll,\n        $focusTrap,\n        toggle,\n        params\n      }\n    }\n    function mounted() {\n      if (props.modelValue) {\n        emit('_before-open', createModalEvent({ type: '_before-open' }))\n        if (emitEvent('before-open', false)) {\n          rejectToggle('show')\n          return\n        }\n\n        let target = getAttachElement()\n        if (target || props.attach === false) {\n          if (props.attach !== false) {\n            if (root.value) {\n              target.appendChild(root.value)\n            } else {\n              visible.value = true\n              nextTick(() => {\n                mounted()\n              })\n              return\n            }\n          }\n\n          let index = props.api.openedModals.findIndex(vm => vm.uid === uid)\n\n          if (index !== -1) {\n            // if this is already exist in modalStack, delete it\n            props.api.openedModals.splice(index, 1)\n          }\n          props.api.openedModals.push(getModalInfo())\n\n          modalStackIndex.value = props.api.openedModals.length - 1\n\n          handleLockScroll()\n\n          props.api.openedModals\n            .filter(vm => vm.uid !== uid)\n            .forEach((vm, index) => {\n              if (vm.getAttachElement() === target) {\n                // if vm and this have the same attach element\n                vm.modalStackIndex.value = index\n                !vm.props.keepOverlay && (vm.visibility.overlay = false)\n              }\n            })\n\n          visible.value = true\n          startTransitionEnter()\n        } else if (target !== false) {\n          console.warn('Unable to locate target '.concat(props.attach))\n        }\n      }\n    }\n    function close() {\n      let index = props.api.openedModals.findIndex(vm => vm.uid === uid)\n      if (index !== -1) {\n        // remove this in modalStack\n        props.api.openedModals.splice(index, 1)\n      }\n      if (props.api.openedModals.length > 0) {\n        // If there are still nested modals opened\n        const $_vm = props.api.openedModals[props.api.openedModals.length - 1]\n        $_vm.props.focusTrap && $_vm.$focusTrap.firstElement().focus()\n        if ($_vm.props.focusRetain || $_vm.props.focusTrap) {\n          $_vm.vfmContainer.value.focus()\n        }\n        !$_vm.props.hideOverlay && ($_vm.visibility.overlay = true)\n      }\n      props.drag && removeDragDown()\n      props.resize && removeResizeDown()\n      _state.value = null\n\n      startTransitionLeave()\n    }\n    function handleLockScroll() {\n      if (props.modelValue) {\n        nextTick(() => {\n          if (props.lockScroll) {\n            disableBodyScroll(vfmContainer.value, {\n              reserveScrollBarGap: true\n            })\n          } else {\n            enableBodyScroll(vfmContainer.value)\n          }\n        })\n      }\n    }\n    function getAttachElement() {\n      let target\n      if (props.attach === false) {\n        target = false\n      } else if (typeof props.attach === 'string') {\n        // CSS selector\n        if (window) {\n          target = window.document.querySelector(props.attach)\n        } else {\n          target = false\n        }\n      } else {\n        // DOM Element\n        target = props.attach\n      }\n      return target\n    }\n    function startTransitionEnter() {\n      visibility.overlay = true\n      visibility.modal = true\n    }\n    function startTransitionLeave() {\n      visibility.overlay = false\n      visibility.modal = false\n    }\n\n    function beforeOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Entering\n    }\n    function afterOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Enter\n    }\n    function beforeOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leaving\n    }\n    function afterOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leave\n    }\n    function beforeModalEnter() {\n      modalTransitionState.value = TransitionState.Entering\n    }\n    function afterModalEnter() {\n      modalTransitionState.value = TransitionState.Enter\n      if (props.focusRetain || props.focusTrap) {\n        vfmContainer.value.focus()\n      }\n      props.focusTrap && $focusTrap.enable(vfmContainer.value)\n      props.drag && addDragDown()\n      props.resize && addResizeDown()\n\n      emit('_opened')\n      emit('opened', createModalEvent({ type: 'opened' }))\n      resolveToggle('show')\n    }\n    function beforeModalLeave() {\n      modalTransitionState.value = TransitionState.Leaving\n\n      if ($focusTrap.enabled()) {\n        $focusTrap.disable()\n      }\n    }\n    function afterModalLeave() {\n      modalTransitionState.value = TransitionState.Leave\n      modalStackIndex.value = null\n      props.lockScroll && enableBodyScroll(vfmContainer.value)\n      if (!props.keepChangedStyle) {\n        dragResizeStyle.value = {}\n      }\n\n      let stopEvent = false\n      const event = createModalEvent({\n        type: 'closed',\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit('_closed')\n      emit('closed', event)\n      resolveToggle('hide')\n      if (stopEvent) return\n      params.value = {}\n    }\n    function onMousedown(e) {\n      lastMousedownEl.value = e?.target\n    }\n    function onMouseupContainer() {\n      // skip when the lastMousedownEl didn't equal vfmContainer\n      if (lastMousedownEl.value !== vfmContainer.value) return\n      // skip when state equal 'resize:move'\n      if (_state.value === 'resize:move') return\n      emit('click-outside', createModalEvent({ type: 'click-outside' }))\n      props.clickToClose && emit('update:modelValue', false)\n    }\n    function onEsc() {\n      if (visible.value && props.escToClose) {\n        emit('update:modelValue', false)\n      }\n    }\n    function createModalEvent(eventProps = {}) {\n      return {\n        ref: getModalInfo(),\n        ...eventProps\n      }\n    }\n    function emitEvent(eventType, value) {\n      let stopEvent = false\n      const event = createModalEvent({\n        type: eventType,\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit(eventType, event)\n      if (stopEvent) {\n        _stopEvent.value = true\n        nextTick(() => {\n          emit('update:modelValue', value)\n        })\n        return true\n      }\n      return false\n    }\n    function emitState(e, state, action) {\n      _state.value = `${state}:${action}`\n      emit(_state.value, e)\n    }\n    function toggle(show, _params) {\n      return new Promise((resolve, reject) => {\n        resolveToggle = res => {\n          resolve(res)\n          resolveToggle = noop\n        }\n        rejectToggle = err => {\n          reject(err)\n          rejectToggle = noop\n        }\n        const value = typeof show === 'boolean' ? show : !props.modelValue\n        if (value && arguments.length === 2) {\n          params.value = _params\n        }\n        emit('update:modelValue', value)\n      })\n    }\n    function pointerDown(e) {\n      e.stopPropagation()\n      const STATE_RESIZE = 'resize'\n      const STATE_DRAG = 'drag'\n      const direction = e.target.getAttribute('direction')\n      let state\n      if (direction) {\n        state = STATE_RESIZE\n      } else if (validDragElement(e, vfmContent.value, props.dragSelector)) {\n        state = STATE_DRAG\n      } else {\n        return\n      }\n      emitState(e, state, 'start')\n      const down = getPosition(e)\n      const rectContainer = vfmContainer.value.getBoundingClientRect()\n      const rectContent = vfmContent.value.getBoundingClientRect()\n      const isAbsolute = window.getComputedStyle(vfmContent.value).position === 'absolute'\n      const position = {\n        top: trimPx(dragResizeStyle.value.top),\n        left: trimPx(dragResizeStyle.value.left)\n      }\n      const limit = (() => {\n        if (props.fitParent) {\n          const limit = {\n            absolute() {\n              return {\n                minTop: 0,\n                minLeft: 0,\n                maxTop: rectContainer.height - rectContent.height,\n                maxLeft: rectContainer.width - rectContent.width\n              }\n            },\n            relative() {\n              return {\n                minTop: position.top + rectContainer.top - rectContent.top,\n                minLeft: position.left + rectContainer.left - rectContent.left,\n                maxTop: position.top + rectContainer.bottom - rectContent.bottom,\n                maxLeft: position.left + rectContainer.right - rectContent.right\n              }\n            }\n          }\n          return isAbsolute ? limit.absolute() : limit.relative()\n        } else {\n          return {}\n        }\n      })()\n      const resetBodyCursor = state === STATE_RESIZE && setStyle(document.body, 'cursor', resizeCursor[direction])\n\n      const moving = e => {\n        // onPointerMove\n        e.stopPropagation()\n        emitState(e, state, 'move')\n        const move = getPosition(e)\n        let offset = {\n          x: move.x - down.x,\n          y: move.y - down.y\n        }\n        if (state === STATE_RESIZE) {\n          offset = getResizeOffset(direction, offset, rectContainer, rectContent, isAbsolute)\n        }\n\n        let top\n        let left\n        if (isAbsolute) {\n          top = rectContent.top - rectContainer.top + offset.y\n          left = rectContent.left - rectContainer.left + offset.x\n        } else {\n          top = position.top + offset.y\n          left = position.left + offset.x\n        }\n        if (state === STATE_DRAG && props.fitParent) {\n          top = clamp(limit.minTop, top, limit.maxTop)\n          left = clamp(limit.minLeft, left, limit.maxLeft)\n        }\n        const style = {\n          position: 'relative',\n          top: top + 'px',\n          left: left + 'px',\n          margin: 'unset',\n          touchAction: 'none',\n          ...(isAbsolute && {\n            position: 'absolute',\n            transform: 'unset',\n            width: rectContent.width + 'px',\n            height: rectContent.height + 'px'\n          }),\n          ...(offset.width && { width: offset.width + 'px' }),\n          ...(offset.height && { height: offset.height + 'px' })\n        }\n\n        dragResizeStyle.value = {\n          ...dragResizeStyle.value,\n          ...style\n        }\n      }\n      const end = e => {\n        // onPointerUp\n        e.stopPropagation()\n        if (state === STATE_RESIZE) {\n          resetBodyCursor && resetBodyCursor()\n        }\n        // Excute onMouseupContainer before trigger emitState\n        setTimeout(() => {\n          emitState(e, state, 'end')\n        })\n        removeListener('move', document, moving)\n        removeListener('up', document, end)\n      }\n      addListener('move', document, moving)\n      addListener('up', document, end)\n    }\n    function addDragDown() {\n      addListener('down', vfmContent.value, pointerDown)\n      dragResizeStyle.value.touchAction = 'none'\n    }\n    function removeDragDown() {\n      removeListener('down', vfmContent.value, pointerDown)\n    }\n    function addResizeDown() {\n      visibility.resize = true\n      nextTick(() => {\n        addListener('down', vfmResize.value, pointerDown)\n      })\n    }\n    function removeResizeDown() {\n      removeListener('down', vfmResize.value, pointerDown)\n      visibility.resize = false\n    }\n    function getResizeOffset(direction, offset, rectContainer, rectContent, isAbsolute) {\n      const setOffset = dir => {\n        let offsetAxis = offset[dir.axis]\n        offsetAxis = props.fitParent ? clamp(dir.min, offsetAxis, dir.max) : offsetAxis\n        let edge = clamp(dir.minEdge, dir.getEdge(offsetAxis), dir.maxEdge)\n        offsetAxis = dir.getOffsetAxis(edge, isAbsolute)\n        return {\n          [dir.edgeName]: edge,\n          [dir.axis]: offsetAxis\n        }\n      }\n\n      const getDirectionInfo = (position, edgeName, axis, isPositive) => {\n        const rectContentEdge = rectContent[edgeName]\n        const positionOffset = rectContainer[position] - rectContent[position]\n        const EdgeName = capitalize(edgeName)\n        return {\n          axis,\n          edgeName,\n          min: isPositive ? positionOffset : -rectContentEdge,\n          max: isPositive ? rectContentEdge : positionOffset,\n          minEdge: props[`min${EdgeName}`],\n          maxEdge: props[`max${EdgeName}`],\n          getEdge: offsetAxis => rectContent[edgeName] - offsetAxis * (isPositive ? 1 : -1),\n          getOffsetAxis: (edge, isAbsolute) => {\n            const offsetAxis = rectContent[edgeName] - edge\n            if (isAbsolute) {\n              return isPositive ? offsetAxis : 0\n            } else {\n              return ((isPositive ? 1 : -1) * offsetAxis) / 2\n            }\n          }\n        }\n      }\n\n      const directions = {\n        t: ['top', 'height', 'y', true],\n        b: ['bottom', 'height', 'y', false],\n        l: ['left', 'width', 'x', true],\n        r: ['right', 'width', 'x', false]\n      }\n\n      let _offset = { x: 0, y: 0 }\n      direction.split('').forEach(dir => {\n        const directionInfo = getDirectionInfo(...directions[dir])\n        _offset = {\n          ..._offset,\n          ...setOffset(directionInfo)\n        }\n      })\n      return _offset\n    }\n    return {\n      root,\n      vfmContainer,\n      vfmContent,\n      vfmResize,\n      vfmOverlayTransition,\n      vfmTransition,\n      computedOverlayTransition,\n      computedTransition,\n      visible,\n      visibility,\n      params,\n      calculateZIndex,\n      bindStyle,\n      bindContentStyle,\n      beforeOverlayEnter,\n      afterOverlayEnter,\n      beforeOverlayLeave,\n      afterOverlayLeave,\n      beforeModalEnter,\n      afterModalEnter,\n      beforeModalLeave,\n      afterModalLeave,\n      onMousedown,\n      onMouseupContainer,\n      onEsc\n    }\n  }\n}\n</script>\n\n<style lang=\"css\" scoped>\n.vfm--fixed {\n  position: fixed;\n}\n.vfm--absolute {\n  position: absolute;\n}\n.vfm--inset {\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.vfm--overlay {\n  background-color: rgba(0, 0, 0, 0.5);\n}\n.vfm--prevent-none {\n  pointer-events: none;\n}\n.vfm--prevent-auto {\n  pointer-events: auto;\n}\n.vfm--outline-none:focus {\n  outline: none;\n}\n.vfm-enter-active,\n.vfm-leave-active {\n  transition: opacity 0.2s;\n}\n.vfm-enter-from,\n.vfm-leave-to {\n  opacity: 0;\n}\n\n.vfm--touch-none {\n  touch-action: none;\n}\n.vfm--select-none {\n  user-select: none;\n}\n\n.vfm--resize-tr,\n.vfm--resize-br,\n.vfm--resize-bl,\n.vfm--resize-tl {\n  width: 12px;\n  height: 12px;\n  z-index: 10;\n}\n\n.vfm--resize-t {\n  top: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-tr {\n  top: -6px;\n  right: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-r {\n  top: 0;\n  right: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-br {\n  bottom: -6px;\n  right: -6px;\n  cursor: nwse-resize;\n}\n.vfm--resize-b {\n  bottom: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-bl {\n  bottom: -6px;\n  left: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-l {\n  top: 0;\n  left: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-tl {\n  top: -6px;\n  left: -6px;\n  cursor: nwse-resize;\n}\n</style>\n", "function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n", "<template>\n  <div class=\"modals-container\">\n    <component\n      :is=\"modal.component\"\n      v-for=\"(modal, index) in api.dynamicModals\"\n      :key=\"modal.id\"\n      v-bind=\"modal.bind\"\n      v-model=\"modal.value\"\n      v-on=\"modal.on\"\n      @_closed=\"slice(index)\"\n      @_beforeOpen=\"e => beforeOpen(e, modal)\"\n      @_opened=\"modal.opened\"\n    >\n      <template v-for=\"(slot, key) in modal.slots\" #[key] :key=\"key\">\n        <!-- eslint-disable vue/no-v-html -->\n        <div v-if=\"isString(slot)\" v-html=\"slot\"></div>\n        <component :is=\"slot.component\" v-else v-bind=\"slot.bind\" v-on=\"slot.on || {}\" />\n      </template>\n    </component>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {},\n  methods: {\n    slice(index) {\n      this.api.dynamicModals.splice(index, 1)\n    },\n    async beforeOpen(e, modal, index) {\n      e.ref.params.value = modal.params\n      await this.$nextTick()\n      await this.$nextTick()\n      if (!modal.value) {\n        this.slice(index)\n        modal.reject('show')\n      }\n    },\n    isString(val) {\n      return typeof val === 'string'\n    }\n  }\n}\n</script>\n", "<template>\n  <div class=\"modals-container\">\n    <component\n      :is=\"modal.component\"\n      v-for=\"(modal, index) in api.dynamicModals\"\n      :key=\"modal.id\"\n      v-bind=\"modal.bind\"\n      v-model=\"modal.value\"\n      v-on=\"modal.on\"\n      @_closed=\"slice(index)\"\n      @_beforeOpen=\"e => beforeOpen(e, modal)\"\n      @_opened=\"modal.opened\"\n    >\n      <template v-for=\"(slot, key) in modal.slots\" #[key] :key=\"key\">\n        <!-- eslint-disable vue/no-v-html -->\n        <div v-if=\"isString(slot)\" v-html=\"slot\"></div>\n        <component :is=\"slot.component\" v-else v-bind=\"slot.bind\" v-on=\"slot.on || {}\" />\n      </template>\n    </component>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {},\n  methods: {\n    slice(index) {\n      this.api.dynamicModals.splice(index, 1)\n    },\n    async beforeOpen(e, modal, index) {\n      e.ref.params.value = modal.params\n      await this.$nextTick()\n      await this.$nextTick()\n      if (!modal.value) {\n        this.slice(index)\n        modal.reject('show')\n      }\n    },\n    isString(val) {\n      return typeof val === 'string'\n    }\n  }\n}\n</script>\n", "import VueFinalModal from './VueFinalModal.vue'\nimport ModalsContainer from './ModalsContainer.vue'\nimport { shallowReactive } from 'vue'\n\nexport function defineApi() {\n  let _modalComponent = null\n\n  return {\n    show(modal, ...args) {\n      switch (typeof modal) {\n        case 'string':\n          return this.toggle(modal, true, ...args)\n        case 'object': {\n          return Promise.allSettled([\n            new Promise((resolve, reject) => {\n              const defaultModal = {\n                value: true,\n                id: Symbol('dynamicModal'),\n                component: _modalComponent,\n                bind: {},\n                slots: {},\n                on: {},\n                params: args[0],\n                reject,\n                opened() {\n                  resolve('show')\n                }\n              }\n              this.dynamicModals.push(shallowReactive(Object.assign(defaultModal, modal)))\n            })\n          ])\n        }\n      }\n    },\n    hide(...names) {\n      return this.toggle(names, false)\n    },\n    hideAll() {\n      return this.hide(...this.openedModals.map(modal => modal.props.name))\n    },\n    toggle(name, ...args) {\n      const modals = Array.isArray(name) ? this.get(...name) : this.get(name)\n      return Promise.allSettled(modals.map(modal => modal.toggle(...args)))\n    },\n    get(...names) {\n      return this.modals.filter(modal => names.includes(modal.props.name))\n    },\n    dynamicModals: shallowReactive([]),\n    openedModals: [],\n    modals: [],\n    _setDefaultModal(modalComponent) {\n      _modalComponent = modalComponent\n    }\n  }\n}\n\nfunction bindApi(component, api) {\n  const _component = { ...component, props: { ...component.props } }\n  Object.assign(_component.props, {\n    api: { type: Object, default: () => api }\n  })\n  return _component\n}\n\nexport function defineModal(api) {\n  const modalComponent = bindApi(VueFinalModal, api)\n  api._setDefaultModal(modalComponent)\n  return modalComponent\n}\n\nexport function defineContainer(api) {\n  return bindApi(ModalsContainer, api)\n}\n", "import { defineApi, defineModal, defineContainer } from './PluginCore'\n\n/**\n * @description Ensure that `_vfm` is used when function `installPlugin` is executed for the first time\n */\nlet _count = 0\n\nconst _key = '$vfm'\nconst _componentName = 'VueFinalModal'\nconst _dynamicContainerName = 'ModalsContainer'\n\n/**\n * @description Support create multiple vfm instance\n */\nexport const defineVfm = () => {\n  let api = defineApi()\n  return {\n    [_key]: api,\n    [_componentName]: defineModal(api),\n    [_dynamicContainerName]: defineContainer(api)\n  }\n}\n\n/**\n * @description Create a vfm instance by default for directly support `import { $vfm, VueFinalModal, ModalsContainer } from 'vue-final-modal'`\n */\nconst _vfm = defineVfm()\nexport const { $vfm, VueFinalModal, ModalsContainer } = _vfm\n\n/**\n * @description Register vfm instance globally\n * @deprecated not available in vue-final-modal 4\n */\nconst installVfm = (App, options = {}) => {\n  const { $vfm, VueFinalModal, ModalsContainer } = _count === 0 ? _vfm : defineVfm()\n  _count += 1\n  const key = options.key || _key\n  const componentName = options.componentName || _componentName\n  const dynamicContainerName = options.dynamicContainerName || _dynamicContainerName\n  Object.defineProperty(App.config.globalProperties, key, {\n    get() {\n      return $vfm\n    }\n  })\n  App.provide(key, $vfm)\n  App.component(componentName, VueFinalModal)\n  App.component(dynamicContainerName, ModalsContainer)\n}\n\n/**\n * @description Vue plugin for register vfm instance globally\n * @deprecated not available in vue-final-modal 4\n */\nexport const vfmPlugin = pluginOptions => ({\n  install(App, options) {\n    const _options = Object.assign({}, pluginOptions, options)\n    installVfm(App, _options)\n  }\n})\n\nvfmPlugin.install = installVfm\n", "import d from \"./node_modules/vue-final-modal/dist/VueFinalModal.esm.js\";export default d;\nexport * from \"./node_modules/vue-final-modal/dist/VueFinalModal.esm.js\""],
  "mappings": "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",
  "names": []
}
